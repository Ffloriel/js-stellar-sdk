{"code":"import URI from 'urijs';\r\nimport { xdr, StrKey, Asset } from 'stellar-base';\r\nimport BigNumber from 'bignumber.js';\r\nimport { BadResponseError } from './errors';\r\nimport { AccountCallBuilder } from './account_call_builder';\r\nimport { AccountResponse } from './account_response';\r\nimport { CallBuilder } from './call_builder';\r\nimport { Config } from './config';\r\nimport HorizonAxiosClient, { getCurrentServerTime } from './horizon_axios_client';\r\nimport { LedgerCallBuilder } from './ledger_call_builder';\r\nimport { TransactionCallBuilder } from './transaction_call_builder';\r\nimport { OperationCallBuilder } from './operation_call_builder';\r\nimport { OfferCallBuilder } from './offer_call_builder';\r\nimport { OrderbookCallBuilder } from './orderbook_call_builder';\r\nimport { TradesCallBuilder } from './trades_call_builder';\r\nimport { PathCallBuilder } from './path_call_builder';\r\nimport { PaymentCallBuilder } from './payment_call_builder';\r\nimport { EffectCallBuilder } from './effect_call_builder';\r\nimport { FriendbotBuilder } from './friendbot_builder';\r\nimport { AssetsCallBuilder } from './assets_call_builder';\r\nimport { TradeAggregationCallBuilder } from './trade_aggregation_call_builder';\r\nexport const SUBMIT_TRANSACTION_TIMEOUT = 60 * 1000;\r\nconst STROOPS_IN_LUMEN = 10000000;\r\nfunction _getAmountInLumens(amt) {\r\n    return new BigNumber(amt).div(STROOPS_IN_LUMEN).toString();\r\n}\r\n/**\r\n * Server handles the network connection to a [Horizon](https://www.stellar.org/developers/horizon/learn/index.html)\r\n * instance and exposes an interface for requests to that instance.\r\n * @constructor\r\n * @param {string} serverURL Horizon Server URL (ex. `https://horizon-testnet.stellar.org`).\r\n * @param {object} [opts] Options object\r\n * @param {boolean} [opts.allowHttp] - Allow connecting to http servers, default: `false`. This must be set to false in production deployments! You can also use {@link Config} class to set this globally.\r\n */\r\nexport class Server {\r\n    constructor(serverURL, opts = {}) {\r\n        this.serverURL = URI(serverURL);\r\n        let allowHttp = Config.isAllowHttp();\r\n        if (typeof opts.allowHttp !== 'undefined') {\r\n            allowHttp = opts.allowHttp;\r\n        }\r\n        if (this.serverURL.protocol() !== 'https' && !allowHttp) {\r\n            throw new Error('Cannot connect to insecure horizon server');\r\n        }\r\n    }\r\n    /**\r\n     * Get timebounds for N seconds from now, when you're creating a transaction\r\n     * with {@link TransactionBuilder}.\r\n     *\r\n     * By default, {@link TransactionBuilder} uses the current local time, but\r\n     * your machine's local time could be different from Horizon's. This gives you\r\n     * more assurance that your timebounds will reflect what you want.\r\n     *\r\n     * Note that this will generate your timebounds when you **init the transaction**,\r\n     * not when you build or submit the transaction! So give yourself enough time to get\r\n     * the transaction built and signed before submitting.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```javascript\r\n     * const transaction = new StellarSdk.TransactionBuilder(accountId, {\r\n     *  fee: await StellarSdk.Server.fetchBaseFee(),\r\n     *  timebounds: await StellarSdk.Server.fetchTimebounds(100)\r\n     * })\r\n     *  .addOperation(operation)\r\n     *  // normally we would need to call setTimeout here, but setting timebounds\r\n     *  // earlier does the trick!\r\n     *  .build();\r\n     * ```\r\n     * @argument {number} seconds Number of seconds past the current time to wait.\r\n     * @argument {bool} [_isRetry=false] True if this is a retry. Only set this internally!\r\n     * This is to avoid a scenario where Horizon is horking up the wrong date.\r\n     * @returns {Promise<number>} Promise that resolves a `timebounds` object\r\n     * (with the shape `{ minTime: 0, maxTime: N }`) that you can set the `timebounds` option to.\r\n     */\r\n    fetchTimebounds(seconds, _isRetry = false) {\r\n        // HorizonAxiosClient instead of this.ledgers so we can get at them headers\r\n        const currentTime = getCurrentServerTime(this.serverURL.hostname());\r\n        if (currentTime) {\r\n            return Promise.resolve({\r\n                minTime: 0,\r\n                maxTime: currentTime + seconds\r\n            });\r\n        }\r\n        // if this is a retry, then the retry has failed, so use local time\r\n        if (_isRetry) {\r\n            return Promise.resolve({\r\n                minTime: 0,\r\n                maxTime: Math.floor(new Date().getTime() / 1000) + seconds\r\n            });\r\n        }\r\n        // otherwise, retry (by calling the root endpoint)\r\n        // toString automatically adds the trailing slash\r\n        return HorizonAxiosClient.get(URI(this.serverURL).toString()).then(() => this.fetchTimebounds(seconds, true));\r\n    }\r\n    /**\r\n     * Fetch the base fee. Since this hits the server, if the server call fails,\r\n     * you might get an error. You should be prepared to use a default value if\r\n     * that happens!\r\n     * @returns {Promise<number>} Promise that resolves to the base fee.\r\n     */\r\n    fetchBaseFee() {\r\n        return this.ledgers()\r\n            .order('desc')\r\n            .limit(1)\r\n            .call()\r\n            .then((response) => {\r\n            if (response && response.records[0]) {\r\n                return response.records[0].base_fee_in_stroops || 100;\r\n            }\r\n            return 100;\r\n        });\r\n    }\r\n    /**\r\n     * Fetch the operation fee stats endpoint.\r\n     * @see [Operation Fee Stats](https://www.stellar.org/developers/horizon/reference/operation-fee-stats.html)\r\n     * @returns {Promise} Promise that resolves to the fee stats returned by Horizon.\r\n     */\r\n    operationFeeStats() {\r\n        const cb = new CallBuilder(URI(this.serverURL));\r\n        cb.filter.push(['operation_fee_stats']);\r\n        return cb.call();\r\n    }\r\n    /**\r\n     * Submits a transaction to the network.\r\n     *\r\n     * If you submit any number of `manageOffer` operations, this will add\r\n     * an attribute to the response that will help you analyze what happened\r\n     * with your offers.\r\n     *\r\n     * Ex:\r\n     * ```javascript\r\n     * const res = {\r\n     *   ...response,\r\n     *   offerResults: [\r\n     *     {\r\n     *       // Exact ordered list of offers that executed, with the exception\r\n     *       // that the last one may not have executed entirely.\r\n     *       offersClaimed: [\r\n     *         sellerId: String,\r\n     *         offerId: String,\r\n     *         assetSold: {\r\n     *           type: 'native|credit_alphanum4|credit_alphanum12',\r\n     *\r\n     *           // these are only present if the asset is not native\r\n     *           assetCode: String,\r\n     *           issuer: String,\r\n     *         },\r\n     *\r\n     *         // same shape as assetSold\r\n     *         assetBought: {}\r\n     *       ],\r\n     *\r\n     *       // What effect your manageOffer op had\r\n     *       effect: \"manageOfferCreated|manageOfferUpdated|manageOfferDeleted\",\r\n     *\r\n     *       // Whether your offer immediately got matched and filled\r\n     *       wasImmediatelyFilled: Boolean,\r\n     *\r\n     *       // Whether your offer immediately got deleted, if for example the order was too small\r\n     *       wasImmediatelyDeleted: Boolean,\r\n     *\r\n     *       // Whether the offer was partially, but not completely, filled\r\n     *       wasPartiallyFilled: Boolean,\r\n     *\r\n     *       // The full requested amount of the offer is open for matching\r\n     *       isFullyOpen: Boolean,\r\n     *\r\n     *       // The total amount of tokens bought / sold during transaction execution\r\n     *       amountBought: Number,\r\n     *       amountSold: Number,\r\n     *\r\n     *       // if the offer was created, updated, or partially filled, this is\r\n     *       // the outstanding offer\r\n     *       currentOffer: {\r\n     *         offerId: String,\r\n     *         amount: String,\r\n     *         price: {\r\n     *           n: String,\r\n     *           d: String,\r\n     *         },\r\n     *\r\n     *         selling: {\r\n     *           type: 'native|credit_alphanum4|credit_alphanum12',\r\n     *\r\n     *           // these are only present if the asset is not native\r\n     *           assetCode: String,\r\n     *           issuer: String,\r\n     *         },\r\n     *\r\n     *         // same as `selling`\r\n     *         buying: {},\r\n     *       },\r\n     *\r\n     *       // the index of this particular operation in the op stack\r\n     *       operationIndex: Number\r\n     *     }\r\n     *   ]\r\n     * }\r\n     * ```\r\n     *\r\n     * For example, you'll want to examine `offerResults` to add affordances\r\n     * like these to your app:\r\n     * * If `wasImmediatelyFilled` is true, then no offer was created. So if you\r\n     * normally watch the `Server.offers` endpoint for offer updates, you instead\r\n     * need to check `Server.trades` to find the result of this filled offer.\r\n     * * If `wasImmediatelyDeleted` is true, then the offer you submitted was\r\n     * deleted without reaching the orderbook or being matched (possibly because\r\n     * your amounts were rounded down to zero). So treat the just-submitted offer\r\n     * request as if it never happened.\r\n     * * If `wasPartiallyFilled` is true, you can tell the user that `amountBought`\r\n     * or `amountSold` have already been transferred.\r\n     *\r\n     * @see [Post Transaction](https://www.stellar.org/developers/horizon/reference/transactions-create.html)\r\n     * @param {Transaction} transaction - The transaction to submit.\r\n     * @returns {Promise} Promise that resolves or rejects with response from horizon.\r\n     */\r\n    submitTransaction(transaction) {\r\n        const tx = encodeURIComponent(transaction\r\n            .toEnvelope()\r\n            .toXDR()\r\n            .toString('base64'));\r\n        return HorizonAxiosClient.post(URI(this.serverURL)\r\n            .segment('transactions')\r\n            .toString(), `tx=${tx}`, { timeout: SUBMIT_TRANSACTION_TIMEOUT })\r\n            .then((response) => {\r\n            if (!response.data.result_xdr) {\r\n                return response.data;\r\n            }\r\n            const responseXDR = xdr.TransactionResult.fromXDR(response.data.result_xdr, 'base64');\r\n            const results = responseXDR.result().value();\r\n            let offerResults;\r\n            let hasManageOffer;\r\n            if (results.length) {\r\n                offerResults = results\r\n                    .map((result, i) => {\r\n                    if (result.value().switch().name !== 'manageOffer') {\r\n                        return null;\r\n                    }\r\n                    hasManageOffer = true;\r\n                    let amountBought = new BigNumber(0);\r\n                    let amountSold = new BigNumber(0);\r\n                    const offerSuccess = result\r\n                        .value()\r\n                        .value()\r\n                        .success();\r\n                    const offersClaimed = offerSuccess\r\n                        .offersClaimed()\r\n                        .map((offerClaimed) => {\r\n                        const claimedOfferAmountBought = new BigNumber(\r\n                        // amountBought is a js-xdr hyper\r\n                        offerClaimed.amountBought().toString());\r\n                        const claimedOfferAmountSold = new BigNumber(\r\n                        // amountBought is a js-xdr hyper\r\n                        offerClaimed.amountSold().toString());\r\n                        // This is an offer that was filled by the one just submitted.\r\n                        // So this offer has an _opposite_ bought/sold frame of ref\r\n                        // than from what we just submitted!\r\n                        // So add this claimed offer's bought to the SOLD count and vice v\r\n                        amountBought = amountBought.add(claimedOfferAmountSold);\r\n                        amountSold = amountSold.add(claimedOfferAmountBought);\r\n                        const sold = Asset.fromOperation(offerClaimed.assetSold());\r\n                        const bought = Asset.fromOperation(offerClaimed.assetBought());\r\n                        const assetSold = {\r\n                            type: sold.getAssetType(),\r\n                            assetCode: sold.getCode(),\r\n                            issuer: sold.getIssuer()\r\n                        };\r\n                        const assetBought = {\r\n                            type: bought.getAssetType(),\r\n                            assetCode: bought.getCode(),\r\n                            issuer: bought.getIssuer()\r\n                        };\r\n                        return {\r\n                            sellerId: StrKey.encodeEd25519PublicKey(offerClaimed.sellerId().ed25519()),\r\n                            offerId: offerClaimed.offerId().toString(),\r\n                            assetSold,\r\n                            amountSold: _getAmountInLumens(claimedOfferAmountSold),\r\n                            assetBought,\r\n                            amountBought: _getAmountInLumens(claimedOfferAmountBought)\r\n                        };\r\n                    });\r\n                    const effect = offerSuccess.offer().switch().name;\r\n                    let currentOffer;\r\n                    if (typeof offerSuccess.offer().value === 'function' &&\r\n                        offerSuccess.offer().value()) {\r\n                        const offerXDR = offerSuccess.offer().value();\r\n                        currentOffer = {\r\n                            offerId: offerXDR.offerId().toString(),\r\n                            selling: {},\r\n                            buying: {},\r\n                            amount: _getAmountInLumens(offerXDR.amount().toString()),\r\n                            price: {\r\n                                n: offerXDR.price().n(),\r\n                                d: offerXDR.price().d()\r\n                            }\r\n                        };\r\n                        const selling = Asset.fromOperation(offerXDR.selling());\r\n                        currentOffer.selling = {\r\n                            type: selling.getAssetType(),\r\n                            assetCode: selling.getCode(),\r\n                            issuer: selling.getIssuer()\r\n                        };\r\n                        const buying = Asset.fromOperation(offerXDR.buying());\r\n                        currentOffer.buying = {\r\n                            type: buying.getAssetType(),\r\n                            assetCode: buying.getCode(),\r\n                            issuer: buying.getIssuer()\r\n                        };\r\n                    }\r\n                    return {\r\n                        offersClaimed,\r\n                        effect,\r\n                        operationIndex: i,\r\n                        currentOffer,\r\n                        // this value is in stroops so divide it out\r\n                        amountBought: _getAmountInLumens(amountBought),\r\n                        amountSold: _getAmountInLumens(amountSold),\r\n                        isFullyOpen: !offersClaimed.length && effect !== 'manageOfferDeleted',\r\n                        wasPartiallyFilled: !!offersClaimed.length && effect !== 'manageOfferDeleted',\r\n                        wasImmediatelyFilled: !!offersClaimed.length && effect === 'manageOfferDeleted',\r\n                        wasImmediatelyDeleted: !offersClaimed.length && effect === 'manageOfferDeleted'\r\n                    };\r\n                })\r\n                    .filter((result) => !!result);\r\n            }\r\n            return Object.assign({}, response.data, {\r\n                offerResults: hasManageOffer ? offerResults : undefined\r\n            });\r\n        })\r\n            .catch((response) => {\r\n            if (response instanceof Error) {\r\n                return Promise.reject(response);\r\n            }\r\n            return Promise.reject(new BadResponseError(`Transaction submission failed. Server responded: ${response.status} ${response.statusText}`, response.data));\r\n        });\r\n    }\r\n    /**\r\n     * @returns {AccountCallBuilder} New {@link AccountCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    accounts() {\r\n        return new AccountCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * @returns {LedgerCallBuilder} New {@link LedgerCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    ledgers() {\r\n        return new LedgerCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * @returns {TransactionCallBuilder} New {@link TransactionCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    transactions() {\r\n        return new TransactionCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * People on the Stellar network can make offers to buy or sell assets. This endpoint represents all the offers a particular account makes.\r\n     * Currently this method only supports querying offers for account and should be used like this:\r\n     * ```\r\n     * server.offers('accounts', accountId).call()\r\n     *  .then(function(offers) {\r\n     *    console.log(offers);\r\n     *  });\r\n     * ```\r\n     * @param {string} resource Resource to query offers\r\n     * @param {...string} resourceParams Parameters for selected resource\r\n     * @returns {OfferCallBuilder} New {@link OfferCallBuilder} object\r\n     */\r\n    offers(resource, ...resourceParams) {\r\n        return new OfferCallBuilder(URI(this.serverURL), resource, ...resourceParams);\r\n    }\r\n    /**\r\n     * @param {Asset} selling Asset being sold\r\n     * @param {Asset} buying Asset being bought\r\n     * @returns {OrderbookCallBuilder} New {@link OrderbookCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    orderbook(selling, buying) {\r\n        return new OrderbookCallBuilder(URI(this.serverURL), selling, buying);\r\n    }\r\n    /**\r\n     * Returns\r\n     * @returns {TradesCallBuilder} New {@link TradesCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    trades() {\r\n        return new TradesCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * @returns {OperationCallBuilder} New {@link OperationCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    operations() {\r\n        return new OperationCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * The Stellar Network allows payments to be made between assets through path payments. A path payment specifies a\r\n     * series of assets to route a payment through, from source asset (the asset debited from the payer) to destination\r\n     * asset (the asset credited to the payee).\r\n     *\r\n     * A path search is specified using:\r\n     *\r\n     * * The destination address\r\n     * * The source address\r\n     * * The asset and amount that the destination account should receive\r\n     *\r\n     * As part of the search, horizon will load a list of assets available to the source address and will find any\r\n     * payment paths from those source assets to the desired destination asset. The search's amount parameter will be\r\n     * used to determine if there a given path can satisfy a payment of the desired amount.\r\n     *\r\n     * @param {string} source The sender's account ID. Any returned path will use a source that the sender can hold.\r\n     * @param {string} destination The destination account ID that any returned path should use.\r\n     * @param {Asset} destinationAsset The destination asset.\r\n     * @param {string} destinationAmount The amount, denominated in the destination asset, that any returned path should be able to satisfy.\r\n     * @returns {PathCallBuilder} New {@link PathCallBuilder} object configured with the current Horizon server configuration.\r\n     */\r\n    paths(source, destination, destinationAsset, destinationAmount) {\r\n        return new PathCallBuilder(URI(this.serverURL), source, destination, destinationAsset, destinationAmount);\r\n    }\r\n    /**\r\n     * @returns {PaymentCallBuilder} New {@link PaymentCallBuilder} instance configured with the current\r\n     * Horizon server configuration.\r\n     */\r\n    payments() {\r\n        return new PaymentCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * @returns {EffectCallBuilder} New {@link EffectCallBuilder} instance configured with the current\r\n     * Horizon server configuration\r\n     */\r\n    effects() {\r\n        return new EffectCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * @param {string} address The Stellar ID that you want Friendbot to send lumens to\r\n     * @returns {FriendbotBuilder} New {@link FriendbotBuilder} instance configured with the current\r\n     * Horizon server configuration\r\n     * @private\r\n     */\r\n    friendbot(address) {\r\n        return new FriendbotBuilder(URI(this.serverURL), address);\r\n    }\r\n    /**\r\n     * Get a new {@link AssetsCallBuilder} instance configured with the current\r\n     * Horizon server configuration.\r\n     * @returns {AssetsCallBuilder} New AssetsCallBuilder instance\r\n     */\r\n    assets() {\r\n        return new AssetsCallBuilder(URI(this.serverURL));\r\n    }\r\n    /**\r\n     * Fetches an account's most current state in the ledger and then creates and returns an {@link Account} object.\r\n     * @param {string} accountId - The account to load.\r\n     * @returns {Promise} Returns a promise to the {@link AccountResponse} object with populated sequence number.\r\n     */\r\n    loadAccount(accountId) {\r\n        return this.accounts()\r\n            .accountId(accountId)\r\n            .call()\r\n            .then((res) => new AccountResponse(res));\r\n    }\r\n    /**\r\n     *\r\n     * @param {Asset} base base asset\r\n     * @param {Asset} counter counter asset\r\n     * @param {long} start_time lower time boundary represented as millis since epoch\r\n     * @param {long} end_time upper time boundary represented as millis since epoch\r\n     * @param {long} resolution segment duration as millis since epoch. *Supported values are 5 minutes (300000), 15 minutes (900000), 1 hour (3600000), 1 day (86400000) and 1 week (604800000).\r\n     * @param {long} offset segments can be offset using this parameter. Expressed in milliseconds. *Can only be used if the resolution is greater than 1 hour. Value must be in whole hours, less than the provided resolution, and less than 24 hours.\r\n     * Returns new {@link TradeAggregationCallBuilder} object configured with the current Horizon server configuration.\r\n     * @returns {TradeAggregationCallBuilder} New TradeAggregationCallBuilder instance\r\n     */\r\n    tradeAggregation(base, counter, start_time, end_time, resolution, offset) {\r\n        return new TradeAggregationCallBuilder(URI(this.serverURL), base, counter, start_time, end_time, resolution, offset);\r\n    }\r\n}\r\n","dts":{"name":"/Users/ffloriel/Documents/GitHub/js-stellar-sdk/src/server.d.ts","writeByteOrderMark":false,"text":"import { AccountCallBuilder } from './account_call_builder';\r\nimport { AccountResponse } from './account_response';\r\nimport { LedgerCallBuilder } from './ledger_call_builder';\r\nimport { TransactionCallBuilder } from './transaction_call_builder';\r\nimport { OperationCallBuilder } from './operation_call_builder';\r\nimport { OfferCallBuilder } from './offer_call_builder';\r\nimport { OrderbookCallBuilder } from './orderbook_call_builder';\r\nimport { TradesCallBuilder } from './trades_call_builder';\r\nimport { PathCallBuilder } from './path_call_builder';\r\nimport { PaymentCallBuilder } from './payment_call_builder';\r\nimport { EffectCallBuilder } from './effect_call_builder';\r\nimport { FriendbotBuilder } from './friendbot_builder';\r\nimport { AssetsCallBuilder } from './assets_call_builder';\r\nimport { TradeAggregationCallBuilder } from './trade_aggregation_call_builder';\r\nexport declare const SUBMIT_TRANSACTION_TIMEOUT: number;\r\n/**\r\n * Server handles the network connection to a [Horizon](https://www.stellar.org/developers/horizon/learn/index.html)\r\n * instance and exposes an interface for requests to that instance.\r\n * @constructor\r\n * @param {string} serverURL Horizon Server URL (ex. `https://horizon-testnet.stellar.org`).\r\n * @param {object} [opts] Options object\r\n * @param {boolean} [opts.allowHttp] - Allow connecting to http servers, default: `false`. This must be set to false in production deployments! You can also use {@link Config} class to set this globally.\r\n */\r\nexport declare class Server {\r\n    constructor(serverURL: any, opts?: {});\r\n    /**\r\n     * Get timebounds for N seconds from now, when you're creating a transaction\r\n     * with {@link TransactionBuilder}.\r\n     *\r\n     * By default, {@link TransactionBuilder} uses the current local time, but\r\n     * your machine's local time could be different from Horizon's. This gives you\r\n     * more assurance that your timebounds will reflect what you want.\r\n     *\r\n     * Note that this will generate your timebounds when you **init the transaction**,\r\n     * not when you build or submit the transaction! So give yourself enough time to get\r\n     * the transaction built and signed before submitting.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```javascript\r\n     * const transaction = new StellarSdk.TransactionBuilder(accountId, {\r\n     *  fee: await StellarSdk.Server.fetchBaseFee(),\r\n     *  timebounds: await StellarSdk.Server.fetchTimebounds(100)\r\n     * })\r\n     *  .addOperation(operation)\r\n     *  // normally we would need to call setTimeout here, but setting timebounds\r\n     *  // earlier does the trick!\r\n     *  .build();\r\n     * ```\r\n     * @argument {number} seconds Number of seconds past the current time to wait.\r\n     * @argument {bool} [_isRetry=false] True if this is a retry. Only set this internally!\r\n     * This is to avoid a scenario where Horizon is horking up the wrong date.\r\n     * @returns {Promise<number>} Promise that resolves a `timebounds` object\r\n     * (with the shape `{ minTime: 0, maxTime: N }`) that you can set the `timebounds` option to.\r\n     */\r\n    fetchTimebounds(seconds: any, _isRetry?: boolean): any;\r\n    /**\r\n     * Fetch the base fee. Since this hits the server, if the server call fails,\r\n     * you might get an error. You should be prepared to use a default value if\r\n     * that happens!\r\n     * @returns {Promise<number>} Promise that resolves to the base fee.\r\n     */\r\n    fetchBaseFee(): Promise<any>;\r\n    /**\r\n     * Fetch the operation fee stats endpoint.\r\n     * @see [Operation Fee Stats](https://www.stellar.org/developers/horizon/reference/operation-fee-stats.html)\r\n     * @returns {Promise} Promise that resolves to the fee stats returned by Horizon.\r\n     */\r\n    operationFeeStats(): Promise<any>;\r\n    /**\r\n     * Submits a transaction to the network.\r\n     *\r\n     * If you submit any number of `manageOffer` operations, this will add\r\n     * an attribute to the response that will help you analyze what happened\r\n     * with your offers.\r\n     *\r\n     * Ex:\r\n     * ```javascript\r\n     * const res = {\r\n     *   ...response,\r\n     *   offerResults: [\r\n     *     {\r\n     *       // Exact ordered list of offers that executed, with the exception\r\n     *       // that the last one may not have executed entirely.\r\n     *       offersClaimed: [\r\n     *         sellerId: String,\r\n     *         offerId: String,\r\n     *         assetSold: {\r\n     *           type: 'native|credit_alphanum4|credit_alphanum12',\r\n     *\r\n     *           // these are only present if the asset is not native\r\n     *           assetCode: String,\r\n     *           issuer: String,\r\n     *         },\r\n     *\r\n     *         // same shape as assetSold\r\n     *         assetBought: {}\r\n     *       ],\r\n     *\r\n     *       // What effect your manageOffer op had\r\n     *       effect: \"manageOfferCreated|manageOfferUpdated|manageOfferDeleted\",\r\n     *\r\n     *       // Whether your offer immediately got matched and filled\r\n     *       wasImmediatelyFilled: Boolean,\r\n     *\r\n     *       // Whether your offer immediately got deleted, if for example the order was too small\r\n     *       wasImmediatelyDeleted: Boolean,\r\n     *\r\n     *       // Whether the offer was partially, but not completely, filled\r\n     *       wasPartiallyFilled: Boolean,\r\n     *\r\n     *       // The full requested amount of the offer is open for matching\r\n     *       isFullyOpen: Boolean,\r\n     *\r\n     *       // The total amount of tokens bought / sold during transaction execution\r\n     *       amountBought: Number,\r\n     *       amountSold: Number,\r\n     *\r\n     *       // if the offer was created, updated, or partially filled, this is\r\n     *       // the outstanding offer\r\n     *       currentOffer: {\r\n     *         offerId: String,\r\n     *         amount: String,\r\n     *         price: {\r\n     *           n: String,\r\n     *           d: String,\r\n     *         },\r\n     *\r\n     *         selling: {\r\n     *           type: 'native|credit_alphanum4|credit_alphanum12',\r\n     *\r\n     *           // these are only present if the asset is not native\r\n     *           assetCode: String,\r\n     *           issuer: String,\r\n     *         },\r\n     *\r\n     *         // same as `selling`\r\n     *         buying: {},\r\n     *       },\r\n     *\r\n     *       // the index of this particular operation in the op stack\r\n     *       operationIndex: Number\r\n     *     }\r\n     *   ]\r\n     * }\r\n     * ```\r\n     *\r\n     * For example, you'll want to examine `offerResults` to add affordances\r\n     * like these to your app:\r\n     * * If `wasImmediatelyFilled` is true, then no offer was created. So if you\r\n     * normally watch the `Server.offers` endpoint for offer updates, you instead\r\n     * need to check `Server.trades` to find the result of this filled offer.\r\n     * * If `wasImmediatelyDeleted` is true, then the offer you submitted was\r\n     * deleted without reaching the orderbook or being matched (possibly because\r\n     * your amounts were rounded down to zero). So treat the just-submitted offer\r\n     * request as if it never happened.\r\n     * * If `wasPartiallyFilled` is true, you can tell the user that `amountBought`\r\n     * or `amountSold` have already been transferred.\r\n     *\r\n     * @see [Post Transaction](https://www.stellar.org/developers/horizon/reference/transactions-create.html)\r\n     * @param {Transaction} transaction - The transaction to submit.\r\n     * @returns {Promise} Promise that resolves or rejects with response from horizon.\r\n     */\r\n    submitTransaction(transaction: any): Promise<any>;\r\n    /**\r\n     * @returns {AccountCallBuilder} New {@link AccountCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    accounts(): AccountCallBuilder;\r\n    /**\r\n     * @returns {LedgerCallBuilder} New {@link LedgerCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    ledgers(): LedgerCallBuilder;\r\n    /**\r\n     * @returns {TransactionCallBuilder} New {@link TransactionCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    transactions(): TransactionCallBuilder;\r\n    /**\r\n     * People on the Stellar network can make offers to buy or sell assets. This endpoint represents all the offers a particular account makes.\r\n     * Currently this method only supports querying offers for account and should be used like this:\r\n     * ```\r\n     * server.offers('accounts', accountId).call()\r\n     *  .then(function(offers) {\r\n     *    console.log(offers);\r\n     *  });\r\n     * ```\r\n     * @param {string} resource Resource to query offers\r\n     * @param {...string} resourceParams Parameters for selected resource\r\n     * @returns {OfferCallBuilder} New {@link OfferCallBuilder} object\r\n     */\r\n    offers(resource: any, ...resourceParams: any[]): OfferCallBuilder;\r\n    /**\r\n     * @param {Asset} selling Asset being sold\r\n     * @param {Asset} buying Asset being bought\r\n     * @returns {OrderbookCallBuilder} New {@link OrderbookCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    orderbook(selling: any, buying: any): OrderbookCallBuilder;\r\n    /**\r\n     * Returns\r\n     * @returns {TradesCallBuilder} New {@link TradesCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    trades(): TradesCallBuilder;\r\n    /**\r\n     * @returns {OperationCallBuilder} New {@link OperationCallBuilder} object configured by a current Horizon server configuration.\r\n     */\r\n    operations(): OperationCallBuilder;\r\n    /**\r\n     * The Stellar Network allows payments to be made between assets through path payments. A path payment specifies a\r\n     * series of assets to route a payment through, from source asset (the asset debited from the payer) to destination\r\n     * asset (the asset credited to the payee).\r\n     *\r\n     * A path search is specified using:\r\n     *\r\n     * * The destination address\r\n     * * The source address\r\n     * * The asset and amount that the destination account should receive\r\n     *\r\n     * As part of the search, horizon will load a list of assets available to the source address and will find any\r\n     * payment paths from those source assets to the desired destination asset. The search's amount parameter will be\r\n     * used to determine if there a given path can satisfy a payment of the desired amount.\r\n     *\r\n     * @param {string} source The sender's account ID. Any returned path will use a source that the sender can hold.\r\n     * @param {string} destination The destination account ID that any returned path should use.\r\n     * @param {Asset} destinationAsset The destination asset.\r\n     * @param {string} destinationAmount The amount, denominated in the destination asset, that any returned path should be able to satisfy.\r\n     * @returns {PathCallBuilder} New {@link PathCallBuilder} object configured with the current Horizon server configuration.\r\n     */\r\n    paths(source: any, destination: any, destinationAsset: any, destinationAmount: any): PathCallBuilder;\r\n    /**\r\n     * @returns {PaymentCallBuilder} New {@link PaymentCallBuilder} instance configured with the current\r\n     * Horizon server configuration.\r\n     */\r\n    payments(): PaymentCallBuilder;\r\n    /**\r\n     * @returns {EffectCallBuilder} New {@link EffectCallBuilder} instance configured with the current\r\n     * Horizon server configuration\r\n     */\r\n    effects(): EffectCallBuilder;\r\n    /**\r\n     * @param {string} address The Stellar ID that you want Friendbot to send lumens to\r\n     * @returns {FriendbotBuilder} New {@link FriendbotBuilder} instance configured with the current\r\n     * Horizon server configuration\r\n     * @private\r\n     */\r\n    friendbot(address: any): FriendbotBuilder;\r\n    /**\r\n     * Get a new {@link AssetsCallBuilder} instance configured with the current\r\n     * Horizon server configuration.\r\n     * @returns {AssetsCallBuilder} New AssetsCallBuilder instance\r\n     */\r\n    assets(): AssetsCallBuilder;\r\n    /**\r\n     * Fetches an account's most current state in the ledger and then creates and returns an {@link Account} object.\r\n     * @param {string} accountId - The account to load.\r\n     * @returns {Promise} Returns a promise to the {@link AccountResponse} object with populated sequence number.\r\n     */\r\n    loadAccount(accountId: any): Promise<AccountResponse>;\r\n    /**\r\n     *\r\n     * @param {Asset} base base asset\r\n     * @param {Asset} counter counter asset\r\n     * @param {long} start_time lower time boundary represented as millis since epoch\r\n     * @param {long} end_time upper time boundary represented as millis since epoch\r\n     * @param {long} resolution segment duration as millis since epoch. *Supported values are 5 minutes (300000), 15 minutes (900000), 1 hour (3600000), 1 day (86400000) and 1 week (604800000).\r\n     * @param {long} offset segments can be offset using this parameter. Expressed in milliseconds. *Can only be used if the resolution is greater than 1 hour. Value must be in whole hours, less than the provided resolution, and less than 24 hours.\r\n     * Returns new {@link TradeAggregationCallBuilder} object configured with the current Horizon server configuration.\r\n     * @returns {TradeAggregationCallBuilder} New TradeAggregationCallBuilder instance\r\n     */\r\n    tradeAggregation(base: any, counter: any, start_time: any, end_time: any, resolution: any, offset: any): TradeAggregationCallBuilder;\r\n}\r\n"}}
