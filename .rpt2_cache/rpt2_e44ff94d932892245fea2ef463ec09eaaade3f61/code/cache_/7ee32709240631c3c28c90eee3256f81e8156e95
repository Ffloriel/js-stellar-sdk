{"code":"import axios from 'axios';\r\nimport URI from 'urijs';\r\nimport { StrKey } from 'stellar-base';\r\nimport { Config } from './config';\r\nimport { BadResponseError } from './errors';\r\nimport { StellarTomlResolver } from './stellar_toml_resolver';\r\n// FEDERATION_RESPONSE_MAX_SIZE is the maximum size of response from a federation server\r\nexport const FEDERATION_RESPONSE_MAX_SIZE = 100 * 1024;\r\n/**\r\n * FederationServer handles a network connection to a\r\n * [federation server](https://www.stellar.org/developers/learn/concepts/federation.html)\r\n * instance and exposes an interface for requests to that instance.\r\n */\r\nexport class FederationServer {\r\n    constructor(serverURL, domain, opts = {}) {\r\n        // TODO `domain` regexp\r\n        this.serverURL = URI(serverURL);\r\n        this.domain = domain;\r\n        const allowHttp = typeof opts.allowHttp === 'undefined'\r\n            ? Config.isAllowHttp()\r\n            : opts.allowHttp;\r\n        this.timeout = typeof opts.timeout === 'undefined'\r\n            ? Config.getTimeout()\r\n            : opts.timeout;\r\n        if (this.serverURL.protocol() !== 'https' && !allowHttp) {\r\n            throw new Error('Cannot connect to insecure federation server');\r\n        }\r\n    }\r\n    /**\r\n     * A helper method for handling user inputs that contain `destination` value.\r\n     * It accepts two types of values:\r\n     *\r\n     * * For Stellar address (ex. `bob*stellar.org`) it splits Stellar address and then tries to find information about\r\n     * federation server in `stellar.toml` file for a given domain. It returns a `Promise` which resolves if federation\r\n     * server exists and user has been found and rejects in all other cases.\r\n     * * For Account ID (ex. `GB5XVAABEQMY63WTHDQ5RXADGYF345VWMNPTN2GFUDZT57D57ZQTJ7PS`) it returns a `Promise` which\r\n     * resolves if Account ID is valid and rejects in all other cases. Please note that this method does not check\r\n     * if the account actually exists in a ledger.\r\n     *\r\n     * Example:\r\n     * ```js\r\n     * StellarSdk.FederationServer.resolve('bob*stellar.org')\r\n     *  .then(federationRecord => {\r\n     *    // {\r\n     *    //   account_id: 'GB5XVAABEQMY63WTHDQ5RXADGYF345VWMNPTN2GFUDZT57D57ZQTJ7PS',\r\n     *    //   memo_type: 'id',\r\n     *    //   memo: 100\r\n     *    // }\r\n     *  });\r\n     * ```\r\n     *\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/stellar-toml.html\" target=\"_blank\">Stellar.toml doc</a>\r\n     * @param {string} value Stellar Address (ex. `bob*stellar.org`)\r\n     */\r\n    static resolve(value, opts = {}) {\r\n        // Check if `value` is in account ID format\r\n        if (value.indexOf('*') < 0) {\r\n            if (!StrKey.isValidEd25519PublicKey(value)) {\r\n                return Promise.reject(new Error('Invalid Account ID'));\r\n            }\r\n            return Promise.resolve({ account_id: value });\r\n        }\r\n        const addressParts = value.split('*');\r\n        const [, domain] = addressParts;\r\n        if (addressParts.length !== 2 || !domain) {\r\n            return Promise.reject(new Error('Invalid Stellar address'));\r\n        }\r\n        return FederationServer.createForDomain(domain, opts).then((federationServer) => federationServer.resolveAddress(value));\r\n    }\r\n    /**\r\n     * Creates a `FederationServer` instance based on information from\r\n     * [stellar.toml](https://www.stellar.org/developers/learn/concepts/stellar-toml.html)\r\n     * file for a given domain.\r\n     *\r\n     * If `stellar.toml` file does not exist for a given domain or it does not\r\n     * contain information about a federation server Promise will reject.\r\n     * ```js\r\n     * StellarSdk.FederationServer.createForDomain('acme.com')\r\n     *   .then(federationServer => {\r\n     *     // federationServer.resolveAddress('bob').then(...)\r\n     *   })\r\n     *   .catch(error => {\r\n     *     // stellar.toml does not exist or it does not contain information about federation server.\r\n     *   });\r\n     * ```\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/stellar-toml.html\" target=\"_blank\">Stellar.toml doc</a>\r\n     * @param {string} domain Domain to get federation server for\r\n     * @param {object} [opts] Options object\r\n     * @param {boolean} [opts.allowHttp] - Allow connecting to http servers, default: `false`. This must be set to false in production deployments!\r\n     * @param {number} [opts.timeout] - Allow a timeout, default: 0. Allows user to avoid nasty lag due to TOML resolve issue.\r\n     * @returns {Promise} `Promise` that resolves to a FederationServer object\r\n     */\r\n    static createForDomain(domain, opts = {}) {\r\n        return StellarTomlResolver.resolve(domain, opts).then((tomlObject) => {\r\n            if (!tomlObject.FEDERATION_SERVER) {\r\n                return Promise.reject(new Error('stellar.toml does not contain FEDERATION_SERVER field'));\r\n            }\r\n            return new FederationServer(tomlObject.FEDERATION_SERVER, domain, opts);\r\n        });\r\n    }\r\n    /**\r\n     * Get the federation record if the user was found for a given Stellar address\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @param {string} address Stellar address (ex. `bob*stellar.org`). If `FederationServer` was instantiated with `domain` param only username (ex. `bob`) can be passed.\r\n     * @returns {Promise} Promise that resolves to the federation record\r\n     */\r\n    resolveAddress(address) {\r\n        let stellarAddress = address;\r\n        if (address.indexOf('*') < 0) {\r\n            if (!this.domain) {\r\n                return Promise.reject(new Error('Unknown domain. Make sure `address` contains a domain (ex. `bob*stellar.org`) or pass `domain` parameter when instantiating the server object.'));\r\n            }\r\n            stellarAddress = `${address}*${this.domain}`;\r\n        }\r\n        const url = this.serverURL.query({ type: 'name', q: stellarAddress });\r\n        return this._sendRequest(url);\r\n    }\r\n    /**\r\n     * Given an account ID, get their federation record if the user was found\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @param {string} accountId Account ID (ex. `GBYNR2QJXLBCBTRN44MRORCMI4YO7FZPFBCNOKTOBCAAFC7KC3LNPRYS`)\r\n     * @returns {Promise} A promise that resolves to the federation record\r\n     */\r\n    resolveAccountId(accountId) {\r\n        const url = this.serverURL.query({ type: 'id', q: accountId });\r\n        return this._sendRequest(url);\r\n    }\r\n    /**\r\n     * Given a transactionId, get the federation record if the sender of the transaction was found\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @param {string} transactionId Transaction ID (ex. `3389e9f0f1a65f19736cacf544c2e825313e8447f569233bb8db39aa607c8889`)\r\n     * @returns {Promise} A promise that resolves to the federation record\r\n     */\r\n    resolveTransactionId(transactionId) {\r\n        const url = this.serverURL.query({ type: 'txid', q: transactionId });\r\n        return this._sendRequest(url);\r\n    }\r\n    _sendRequest(url) {\r\n        const timeout = this.timeout;\r\n        return axios\r\n            .get(url.toString(), {\r\n            maxContentLength: FEDERATION_RESPONSE_MAX_SIZE,\r\n            timeout\r\n        })\r\n            .then((response) => {\r\n            if (typeof response.data.memo !== 'undefined' &&\r\n                typeof response.data.memo !== 'string') {\r\n                throw new Error('memo value should be of type string');\r\n            }\r\n            return response.data;\r\n        })\r\n            .catch((response) => {\r\n            if (response instanceof Error) {\r\n                if (response.message.match(/^maxContentLength size/)) {\r\n                    throw new Error(`federation response exceeds allowed size of ${FEDERATION_RESPONSE_MAX_SIZE}`);\r\n                }\r\n                else {\r\n                    return Promise.reject(response);\r\n                }\r\n            }\r\n            else {\r\n                return Promise.reject(new BadResponseError(`Server query failed. Server responded: ${response.status} ${response.statusText}`, response.data));\r\n            }\r\n        });\r\n    }\r\n}\r\n","dts":{"name":"/Users/ffloriel/Documents/GitHub/js-stellar-sdk/src/federation_server.d.ts","writeByteOrderMark":false,"text":"export declare const FEDERATION_RESPONSE_MAX_SIZE: number;\r\ndeclare type FederationServerOptions = {\r\n    allowHttp?: boolean;\r\n    timeout?: number;\r\n};\r\n/**\r\n * FederationServer handles a network connection to a\r\n * [federation server](https://www.stellar.org/developers/learn/concepts/federation.html)\r\n * instance and exposes an interface for requests to that instance.\r\n */\r\nexport declare class FederationServer {\r\n    serverURL: uri.URI;\r\n    domain: string;\r\n    timeout: number;\r\n    constructor(serverURL: string, domain: string, opts?: FederationServerOptions);\r\n    /**\r\n     * A helper method for handling user inputs that contain `destination` value.\r\n     * It accepts two types of values:\r\n     *\r\n     * * For Stellar address (ex. `bob*stellar.org`) it splits Stellar address and then tries to find information about\r\n     * federation server in `stellar.toml` file for a given domain. It returns a `Promise` which resolves if federation\r\n     * server exists and user has been found and rejects in all other cases.\r\n     * * For Account ID (ex. `GB5XVAABEQMY63WTHDQ5RXADGYF345VWMNPTN2GFUDZT57D57ZQTJ7PS`) it returns a `Promise` which\r\n     * resolves if Account ID is valid and rejects in all other cases. Please note that this method does not check\r\n     * if the account actually exists in a ledger.\r\n     *\r\n     * Example:\r\n     * ```js\r\n     * StellarSdk.FederationServer.resolve('bob*stellar.org')\r\n     *  .then(federationRecord => {\r\n     *    // {\r\n     *    //   account_id: 'GB5XVAABEQMY63WTHDQ5RXADGYF345VWMNPTN2GFUDZT57D57ZQTJ7PS',\r\n     *    //   memo_type: 'id',\r\n     *    //   memo: 100\r\n     *    // }\r\n     *  });\r\n     * ```\r\n     *\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/stellar-toml.html\" target=\"_blank\">Stellar.toml doc</a>\r\n     * @param {string} value Stellar Address (ex. `bob*stellar.org`)\r\n     */\r\n    static resolve(value: string, opts?: FederationServerOptions): any;\r\n    /**\r\n     * Creates a `FederationServer` instance based on information from\r\n     * [stellar.toml](https://www.stellar.org/developers/learn/concepts/stellar-toml.html)\r\n     * file for a given domain.\r\n     *\r\n     * If `stellar.toml` file does not exist for a given domain or it does not\r\n     * contain information about a federation server Promise will reject.\r\n     * ```js\r\n     * StellarSdk.FederationServer.createForDomain('acme.com')\r\n     *   .then(federationServer => {\r\n     *     // federationServer.resolveAddress('bob').then(...)\r\n     *   })\r\n     *   .catch(error => {\r\n     *     // stellar.toml does not exist or it does not contain information about federation server.\r\n     *   });\r\n     * ```\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/stellar-toml.html\" target=\"_blank\">Stellar.toml doc</a>\r\n     * @param {string} domain Domain to get federation server for\r\n     * @param {object} [opts] Options object\r\n     * @param {boolean} [opts.allowHttp] - Allow connecting to http servers, default: `false`. This must be set to false in production deployments!\r\n     * @param {number} [opts.timeout] - Allow a timeout, default: 0. Allows user to avoid nasty lag due to TOML resolve issue.\r\n     * @returns {Promise} `Promise` that resolves to a FederationServer object\r\n     */\r\n    static createForDomain(domain: string, opts?: FederationServerOptions): any;\r\n    /**\r\n     * Get the federation record if the user was found for a given Stellar address\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @param {string} address Stellar address (ex. `bob*stellar.org`). If `FederationServer` was instantiated with `domain` param only username (ex. `bob`) can be passed.\r\n     * @returns {Promise} Promise that resolves to the federation record\r\n     */\r\n    resolveAddress(address: any): Promise<any>;\r\n    /**\r\n     * Given an account ID, get their federation record if the user was found\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @param {string} accountId Account ID (ex. `GBYNR2QJXLBCBTRN44MRORCMI4YO7FZPFBCNOKTOBCAAFC7KC3LNPRYS`)\r\n     * @returns {Promise} A promise that resolves to the federation record\r\n     */\r\n    resolveAccountId(accountId: any): Promise<any>;\r\n    /**\r\n     * Given a transactionId, get the federation record if the sender of the transaction was found\r\n     * @see <a href=\"https://www.stellar.org/developers/learn/concepts/federation.html\" target=\"_blank\">Federation doc</a>\r\n     * @param {string} transactionId Transaction ID (ex. `3389e9f0f1a65f19736cacf544c2e825313e8447f569233bb8db39aa607c8889`)\r\n     * @returns {Promise} A promise that resolves to the federation record\r\n     */\r\n    resolveTransactionId(transactionId: any): Promise<any>;\r\n    _sendRequest(url: any): Promise<any>;\r\n}\r\nexport {};\r\n"}}
